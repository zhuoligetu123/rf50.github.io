WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:02.220
Michael さん、今日はお越しいただきありがとうございます

00:00:02.220 --> 00:00:03.790
履歴書に目を通させてもらったんですが

00:00:03.790 --> 00:00:04.969
非常に感心しましたよ

00:00:04.969 --> 00:00:07.049
元々されていた会計の仕事から転身して

00:00:07.049 --> 00:00:10.019
最近は自律型システムの業務に従事されているとか

00:00:10.019 --> 00:00:10.309
はい

00:00:10.310 --> 00:00:12.870
そこで、ぜひお話を伺いたいプロジェクトが 1 つあるんです

00:00:12.869 --> 00:00:16.500
自動運転車に畳み込みニューラルネットを採用したプロジェクトなんですが

00:00:16.500 --> 00:00:20.190
少し詳しくそのお話を聞かせてもらえますか

00:00:20.190 --> 00:00:22.214
その際に直面した課題や

00:00:22.214 --> 00:00:25.019
使用した方法

00:00:25.019 --> 00:00:26.550
今後もしチャンスがあれば

00:00:26.550 --> 00:00:28.195
挑戦してみたいことも踏まえてお願いします

00:00:28.195 --> 00:00:30.375
はいそのプロジェクトでは元々

00:00:30.375 --> 00:00:34.189
高度な車線検出に関するクラスで実践したものより

00:00:34.189 --> 00:00:38.434
堅牢な深層学習アプローチを考案しようとしていたんです

00:00:38.435 --> 00:00:39.975
そのプロジェクトでは

00:00:39.975 --> 00:00:43.725
よく知られたコンピュータービジョン技術を使用しました

00:00:43.725 --> 00:00:46.179
色の異なる勾配などを使って

00:00:46.179 --> 00:00:50.130
画像にあったようなレイラインを見つけるわけです

00:00:50.130 --> 00:00:52.155
それから透視変換を行い

00:00:52.155 --> 00:00:55.730
道路の鳥瞰図を表示しました

00:00:55.729 --> 00:00:58.619
これにはかなりの計算能力が必要とされますので

00:00:58.619 --> 00:01:00.369
実際にはリアルタイムではありませんでした

00:01:00.369 --> 00:01:04.030
3 FPS 位の実行速度だったと思うので

00:01:04.030 --> 00:01:06.780
実際のアプリケーションでは上手くいきません

00:01:06.780 --> 00:01:08.275
アップデートのスピードが間に合わないのです

00:01:08.275 --> 00:01:10.850
そのため、このアプローチでは

00:01:10.849 --> 00:01:13.879
30 FPS 程度の実速度で実行でき

00:01:13.879 --> 00:01:16.649
なおかつ以前よりも堅牢性に優れたものが必要でした

00:01:16.650 --> 00:01:19.640
たとえば最初のアプローチでは曲線での動きがいまいちでした

00:01:19.640 --> 00:01:22.215
大きい曲線に達すると

00:01:22.215 --> 00:01:24.109
アルゴリズムが動作しなくなり

00:01:24.109 --> 00:01:25.875
ページから外れて

00:01:25.875 --> 00:01:28.965
実際には曲がっている線を直線だと考えるんです

00:01:28.965 --> 00:01:32.984
そのトレーニングデータの収集を行ったんですが

00:01:32.984 --> 00:01:35.790
このために自分の車を乗り回し

00:01:35.790 --> 00:01:38.555
携帯でビデオ画像を取り込んで

00:01:38.555 --> 00:01:42.250
トレーニングデータからこれらのフレームを抽出しました

00:01:42.250 --> 00:01:44.165
次はネットワークです

00:01:44.165 --> 00:01:48.180
私のネットワークは、SegNet という当時私が文献で読んだ

00:01:48.180 --> 00:01:49.725
アーキテクチャーに似たものを使って構築しました

00:01:49.724 --> 00:01:51.189
図に描いて説明しますね

00:01:51.189 --> 00:01:52.215
ええ、簡単に説明してもらえますか

00:01:52.215 --> 00:01:54.040
あまりよく知らないので

00:01:54.040 --> 00:01:56.590
SegNet の基本概念ですが

00:01:56.590 --> 00:01:59.975
最初は通常の畳み込みニューラルネットワークのような感じです

00:01:59.974 --> 00:02:03.919
通常、畳み込みニューラルネットワークの出力は

00:02:03.920 --> 00:02:07.290
入力として入ってくる入力画像で行われます

00:02:07.290 --> 00:02:12.719
いくつかの小さい畳み込み層がある連続層があります

00:02:13.680 --> 00:02:16.665
別のネットワークだと

00:02:16.664 --> 00:02:18.709
この時点で層が完全につながっているのが通常かもしれませんが

00:02:18.710 --> 00:02:21.730
完全な畳み込みニューラルネットワークの場合は

00:02:21.729 --> 00:02:24.709
これは SegNet にもあった特徴ですが

00:02:24.710 --> 00:02:28.115
D-畳み込み層と呼ばれる対称性のある構造により

00:02:28.115 --> 00:02:32.000
反対側でも層が大きくなります

00:02:32.000 --> 00:02:34.889
このセマンティック出力により左右が同じサイズになります

00:02:34.889 --> 00:02:37.049
イメージではサイズを変えたりすることも可能ですが

00:02:37.050 --> 00:02:40.630
その出力内にあるピクセルはすべて異なるクラスです

00:02:40.629 --> 00:02:44.030
私の場合は、車線か車線でないかでした

00:02:44.030 --> 00:02:45.770
つまりこれによって

00:02:45.770 --> 00:02:49.085
この 2 つのバイナリー分類をしているわけです

00:02:49.085 --> 00:02:51.510
コースや車両、歩行者などが

00:02:51.509 --> 00:02:54.125
さらに多いアプリケーションもあります

00:02:54.125 --> 00:02:58.080
しかし私の場合は、車線検出アルゴリズムを改善したかっただけなので

00:02:58.080 --> 00:02:59.800
車線自体に着目しました

00:02:59.800 --> 00:03:02.830
道路上の自由空間を検証する別のアプリケーションもいくつかありますが

00:03:02.830 --> 00:03:04.115
個人的には

00:03:04.115 --> 00:03:06.800
道路の反対側に車を走行させたくありません

00:03:06.800 --> 00:03:09.860
自分の車線をしっかりと把握したいんです

00:03:09.860 --> 00:03:13.700
まず最初に直面した問題のひとつは

00:03:13.699 --> 00:03:19.879
これをトレーニングで正しく動作させることでした

00:03:19.879 --> 00:03:23.030
というのも、セマンティックセグメンテーションネットワークも

00:03:23.030 --> 00:03:25.610
実はスキップ層と呼ばれる方法を使用しているんです

00:03:25.610 --> 00:03:29.690
スキップ層を使うのは実に簡単で

00:03:29.689 --> 00:03:33.939
ネットワークの中間セクション全体をスキップしたり

00:03:33.939 --> 00:03:36.689
必要な数の層の間をスキップするのに

00:03:36.689 --> 00:03:40.085
使用できます

00:03:40.085 --> 00:03:44.270
より高度な機能を抽出し

00:03:44.270 --> 00:03:46.310
同時に最大プーリング層を通過した場合

00:03:46.310 --> 00:03:48.289
画像のどこで起こったかに関する情報を大抵は失ってしまうため

00:03:48.289 --> 00:03:50.379
これは大変重要です

00:03:50.379 --> 00:03:52.289
そのため、すべてのピクセルを分類しようとする場合は

00:03:52.289 --> 00:03:54.669
最後までその情報を持ち

00:03:54.669 --> 00:03:57.155
元に戻せるようにしておくことが大切です

00:03:57.155 --> 00:04:02.125
もう 1 つは、逆伝播を実行する際には

00:04:02.125 --> 00:04:04.490
情報が全体に伝達されていることを確認する必要があるという点です

00:04:04.490 --> 00:04:07.295
なぜなら、ネットワークが非常に深い場合

00:04:07.294 --> 00:04:11.359
勾配消失と呼ばれる

00:04:11.360 --> 00:04:14.120
連鎖律の使いすぎで積が元に戻るという問題が

00:04:14.120 --> 00:04:15.830
逆伝播に起こり

00:04:15.830 --> 00:04:18.500
その勾配が消失し始めると、非常に深いネットワークにある

00:04:18.500 --> 00:04:23.225
早期の層にはエラーをフィードしなくなるからなんです

00:04:23.225 --> 00:04:25.820
この問題の修正に有用なのが実はこれです

00:04:25.819 --> 00:04:29.180
その理由というのは、真ん中にあるいくつかの積をスキップし

00:04:29.180 --> 00:04:33.129
逆伝播信号がネットワークの前までずっと継続するためです

00:04:33.129 --> 00:04:36.000
非常に興味深いですねありがとうございました

00:04:36.000 --> 00:04:37.160
こちらこそありがとうございました

